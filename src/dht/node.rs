//! Core node identifiers and distance metrics for the DHT.
//!
//! This module defines the [`NodeId`] type which represents a 256-bit identifier
//! in the Kademlia DHT, along with methods for calculating distances between nodes.

use serde::{Deserialize, Serialize};
use sha3::{Digest, Sha3_256};

/// A 256-bit node identifier used in the Kademlia DHT.
///
/// NodeIds are used to determine the position of nodes in the DHT keyspace and to
/// calculate distances between nodes. They are typically generated by hashing
/// node addresses or public keys.
///
/// # Examples
///
/// ```
/// use rust_p2p_node::dht::node::NodeId;
///
/// // Create NodeId from data
/// let id1 = NodeId::new(b"node_address");
/// let id2 = NodeId::new(b"different_address");
///
/// // Compare distances
/// assert!(!id1.closer_than(&id2, &NodeId::new(b"far_away")));
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct NodeId([u8; 32]);

impl NodeId {
    /// Creates a new NodeId by hashing the input data with SHA3-256.
    ///
    /// # Arguments
    ///
    /// * `data` - The input data to hash
    ///
    /// # Examples
    ///
    /// ```
    /// # use rust_p2p_node::dht::node::NodeId;
    /// let id = NodeId::new(b"node_data");
    /// ```
    pub fn new(data: &[u8]) -> Self {
        let mut hasher = Sha3_256::new();
        hasher.update(data);
        let result = hasher.finalize();
        Self(result.into())
    }

    /// Calculates the XOR distance between two NodeIds.
    ///
    /// In Kademlia, distance between nodes is calculated using XOR metric,
    /// which has useful properties for DHT routing:
    /// - d(x, x) = 0
    /// - d(x, y) = d(y, x)
    /// - d(x, y) + d(y, z) >= d(x, z)
    ///
    /// # Arguments
    ///
    /// * `other` - The other NodeId to calculate distance to
    ///
    /// # Returns
    ///
    /// A 32-byte array representing the XOR distance
    pub fn distance(&self, other: &NodeId) -> [u8; 32] {
        let mut res = [0u8; 32];
        for i in 0..32 {
            res[i] = self.0[i] ^ other.0[i];
        }
        res
    }

    /// Determines whether one node is closer to this node than another.
    ///
    /// Compares two nodes' distances to this node using the XOR metric.
    /// Returns true if `a` is strictly closer than `b`.
    ///
    /// # Arguments
    ///
    /// * `a` - First node to compare
    /// * `b` - Second node to compare
    ///
    /// # Examples
    ///
    /// ```
    /// # use rust_p2p_node::dht::node::NodeId;
    /// let base = NodeId::new(b"base");
    /// let close = NodeId::new(b"closer");
    /// let far = NodeId::new(b"farther");
    ///
    /// assert!(base.closer_than(&close, &far));
    /// assert!(!base.closer_than(&far, &close));
    /// ```
    pub fn closer_than(&self, a: &NodeId, b: &NodeId) -> bool {
        let dist_a = self.distance(a);
        let dist_b = self.distance(b);

        // Compare byte by byte from most significant to least
        for i in 0..32 {
            if dist_a[i] != dist_b[i] {
                return dist_a[i] < dist_b[i];
            }
        }

        false // Equal distances
    }

    /// Returns the number of leading zero bits in the NodeId.
    ///
    /// This is useful for determining the bucket index in the routing table.
    ///
    /// # Examples
    ///
    /// ```
    /// # use rust_p2p_node::dht::node::NodeId;
    /// let id = NodeId::new(b"node");
    /// println!("Leading zeros: {}", id.leading_zeros());
    /// ```
    pub fn leading_zeros(&self) -> usize {
        let mut count = 0;
        for &byte in &self.0 {
            if byte == 0 {
                count += 8;
            } else {
                count += byte.leading_zeros() as usize;
                break;
            }
        }
        count
    }
}

impl std::fmt::Display for NodeId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", hex::encode(self.0))
    }
}

#[cfg(test)]
mod node_id_tests {
    use crate::dht::NodeId;

    #[test]
    fn test_node_id_creation() {
        let data1 = b"test_data";
        let data2 = b"test_data";
        let data3 = b"different_data";

        let id1 = NodeId::new(data1);
        let id2 = NodeId::new(data2);
        let id3 = NodeId::new(data3);

        assert_eq!(id1, id2);
        assert_ne!(id1, id3);
    }

    #[test]
    fn test_distance_calculation() {
        let id1 = NodeId::new(b"node1");
        let id2 = NodeId::new(b"node2");

        let distance = id1.distance(&id2);

        assert_eq!(distance, id2.distance(&id1));
        assert_eq!(id1.distance(&id1), [0u8; 32]);
    }

    #[test]
    fn test_closer_than() {
        let base = NodeId::new(b"base_node");

        let mut close_data = *b"base_node_______________________";
        close_data[31] = 1;
        let close = NodeId::new(&close_data);

        let mut far_data = *b"fase_node_________________";
        far_data[0] = b'f';
        let far = NodeId::new(&far_data);

        assert!(base.closer_than(&close, &far));
        assert!(!base.closer_than(&far, &close));
        assert!(!base.closer_than(&close, &close));
    }
}
